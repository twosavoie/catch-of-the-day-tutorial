{"ast":null,"code":"/*!\n * Stylus - utils\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar nodes = require('./nodes'),\n  basename = require('path').basename,\n  relative = require('path').relative,\n  join = require('path').join,\n  isAbsolute = require('path').isAbsolute,\n  glob = require('glob'),\n  fs = require('fs');\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.absolute = isAbsolute || function (path) {\n  // On Windows the path could start with a drive letter, i.e. a:\\\\ or two leading backslashes.\n  // Also on Windows, the path may have been normalized to forward slashes, so check for this too.\n  return path.substr(0, 2) == '\\\\\\\\' || '/' === path.charAt(0) || /^[a-z]:[\\\\\\/]/i.test(path);\n};\n\n/**\n * Attempt to lookup `path` within `paths` from tail to head.\n * Optionally a path to `ignore` may be passed.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {String}\n * @api private\n */\n\nexports.lookup = function (path, paths, ignore) {\n  var lookup,\n    i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    try {\n      fs.statSync(path);\n      return path;\n    } catch (err) {\n      // Ignore, continue on\n      // to trying relative lookup.\n      // Needed for url(/images/foo.png)\n      // for example\n    }\n  }\n\n  // Relative\n  while (i--) {\n    try {\n      lookup = join(paths[i], path);\n      if (ignore == lookup) continue;\n      fs.statSync(lookup);\n      return lookup;\n    } catch (err) {\n      // Ignore\n    }\n  }\n};\n\n/**\n * Like `utils.lookup` but uses `glob` to find files.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {Array}\n * @api private\n */\nexports.find = function (path, paths, ignore) {\n  var lookup,\n    found,\n    i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    if ((found = glob.sync(path)).length) {\n      return found;\n    }\n  }\n\n  // Relative\n  while (i--) {\n    lookup = join(paths[i], path);\n    if (ignore == lookup) continue;\n    if ((found = glob.sync(lookup)).length) {\n      return found;\n    }\n  }\n};\n\n/**\n * Lookup index file inside dir with given `name`.\n *\n * @param {String} name\n * @return {Array}\n * @api private\n */\n\nexports.lookupIndex = function (name, paths, filename) {\n  // foo/index.styl\n  var found = exports.find(join(name, 'index.styl'), paths, filename);\n  if (!found) {\n    // foo/foo.styl\n    found = exports.find(join(name, basename(name).replace(/\\.styl/i, '') + '.styl'), paths, filename);\n  }\n  if (!found && !~name.indexOf('node_modules')) {\n    // node_modules/foo/.. or node_modules/foo.styl/..\n    found = lookupPackage(join('node_modules', name));\n  }\n  return found;\n  function lookupPackage(dir) {\n    var pkg = exports.lookup(join(dir, 'package.json'), paths, filename);\n    if (!pkg) {\n      return /\\.styl$/i.test(dir) ? exports.lookupIndex(dir, paths, filename) : lookupPackage(dir + '.styl');\n    }\n    var main = require(relative(__dirname, pkg)).main;\n    if (main) {\n      found = exports.find(join(dir, main), paths, filename);\n    } else {\n      found = exports.lookupIndex(dir, paths, filename);\n    }\n    return found;\n  }\n};\n\n/**\n * Format the given `err` with the given `options`.\n *\n * Options:\n *\n *   - `filename`   context filename\n *   - `context`    context line count [8]\n *   - `lineno`     context line number\n *   - `column`     context column number\n *   - `input`        input string\n *\n * @param {Error} err\n * @param {Object} options\n * @return {Error}\n * @api private\n */\n\nexports.formatException = function (err, options) {\n  var lineno = options.lineno,\n    column = options.column,\n    filename = options.filename,\n    str = options.input,\n    context = options.context || 8,\n    context = context / 2,\n    lines = ('\\n' + str).split('\\n'),\n    start = Math.max(lineno - context, 1),\n    end = Math.min(lines.length, lineno + context),\n    pad = end.toString().length;\n  var context = lines.slice(start, end).map(function (line, i) {\n    var curr = i + start;\n    return '   ' + Array(pad - curr.toString().length + 1).join(' ') + curr + '| ' + line + (curr == lineno ? '\\n' + Array(curr.toString().length + 5 + column).join('-') + '^' : '');\n  }).join('\\n');\n  err.message = filename + ':' + lineno + ':' + column + '\\n' + context + '\\n\\n' + err.message + '\\n' + (err.stylusStack ? err.stylusStack + '\\n' : '');\n\n  // Don't show JS stack trace for Stylus errors\n  if (err.fromStylus) err.stack = 'Error: ' + err.message;\n  return err;\n};\n\n/**\n * Assert that `node` is of the given `type`, or throw.\n *\n * @param {Node} node\n * @param {Function} type\n * @param {String} param\n * @api public\n */\n\nexports.assertType = function (node, type, param) {\n  exports.assertPresent(node, param);\n  if (node.nodeName == type) return;\n  var actual = node.nodeName,\n    msg = 'expected ' + (param ? '\"' + param + '\" to be a ' : '') + type + ', but got ' + actual + ':' + node;\n  throw new Error('TypeError: ' + msg);\n};\n\n/**\n * Assert that `node` is a `String` or `Ident`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertString = function (node, param) {\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'string':\n    case 'ident':\n    case 'literal':\n      return;\n    default:\n      var actual = node.nodeName,\n        msg = 'expected string, ident or literal, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that `node` is a `RGBA` or `HSLA`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertColor = function (node, param) {\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'rgba':\n    case 'hsla':\n      return;\n    default:\n      var actual = node.nodeName,\n        msg = 'expected rgba or hsla, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that param `name` is given, aka the `node` is passed.\n *\n * @param {Node} node\n * @param {String} name\n * @api public\n */\n\nexports.assertPresent = function (node, name) {\n  if (node) return;\n  if (name) throw new Error('\"' + name + '\" argument required');\n  throw new Error('argument missing');\n};\n\n/**\n * Unwrap `expr`.\n *\n * Takes an expressions with length of 1\n * such as `((1 2 3))` and unwraps it to `(1 2 3)`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\nexports.unwrap = function (expr) {\n  // explicitly preserve the expression\n  if (expr.preserve) return expr;\n  if ('arguments' != expr.nodeName && 'expression' != expr.nodeName) return expr;\n  if (1 != expr.nodes.length) return expr;\n  if ('arguments' != expr.nodes[0].nodeName && 'expression' != expr.nodes[0].nodeName) return expr;\n  return exports.unwrap(expr.nodes[0]);\n};\n\n/**\n * Coerce JavaScript values to their Stylus equivalents.\n *\n * @param {Mixed} val\n * @param {Boolean} [raw]\n * @return {Node}\n * @api public\n */\n\nexports.coerce = function (val, raw) {\n  switch (typeof val) {\n    case 'function':\n      return val;\n    case 'string':\n      return new nodes.String(val);\n    case 'boolean':\n      return new nodes.Boolean(val);\n    case 'number':\n      return new nodes.Unit(val);\n    default:\n      if (null == val) return nodes.null;\n      if (Array.isArray(val)) return exports.coerceArray(val, raw);\n      if (val.nodeName) return val;\n      return exports.coerceObject(val, raw);\n  }\n};\n\n/**\n * Coerce a javascript `Array` to a Stylus `Expression`.\n *\n * @param {Array} val\n * @param {Boolean} [raw]\n * @return {Expression}\n * @api private\n */\n\nexports.coerceArray = function (val, raw) {\n  var expr = new nodes.Expression();\n  val.forEach(function (val) {\n    expr.push(exports.coerce(val, raw));\n  });\n  return expr;\n};\n\n/**\n * Coerce a javascript object to a Stylus `Expression` or `Object`.\n *\n * For example `{ foo: 'bar', bar: 'baz' }` would become\n * the expression `(foo 'bar') (bar 'baz')`. If `raw` is true\n * given `obj` would become a Stylus hash object.\n *\n * @param {Object} obj\n * @param {Boolean} [raw]\n * @return {Expression|Object}\n * @api public\n */\n\nexports.coerceObject = function (obj, raw) {\n  var node = raw ? new nodes.Object() : new nodes.Expression(),\n    val;\n  for (var key in obj) {\n    val = exports.coerce(obj[key], raw);\n    key = new nodes.Ident(key);\n    if (raw) {\n      node.set(key, val);\n    } else {\n      node.push(exports.coerceArray([key, val]));\n    }\n  }\n  return node;\n};\n\n/**\n * Return param names for `fn`.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\nexports.params = function (fn) {\n  return fn.toString().match(/\\(([^)]*)\\)/)[1].split(/ *, */);\n};\n\n/**\n * Merge object `b` with `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Boolean} [deep]\n * @return {Object} a\n * @api private\n */\nexports.merge = function (a, b, deep) {\n  for (var k in b) {\n    if (deep && a[k]) {\n      var nodeA = exports.unwrap(a[k]).first,\n        nodeB = exports.unwrap(b[k]).first;\n      if ('object' == nodeA.nodeName && 'object' == nodeB.nodeName) {\n        a[k].first.vals = exports.merge(nodeA.vals, nodeB.vals, deep);\n      } else {\n        a[k] = b[k];\n      }\n    } else {\n      a[k] = b[k];\n    }\n  }\n  return a;\n};\n\n/**\n * Returns an array with unique values.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.uniq = function (arr) {\n  var obj = {},\n    ret = [];\n  for (var i = 0, len = arr.length; i < len; ++i) {\n    if (arr[i] in obj) continue;\n    obj[arr[i]] = true;\n    ret.push(arr[i]);\n  }\n  return ret;\n};\n\n/**\n * Compile selector strings in `arr` from the bottom-up\n * to produce the selector combinations. For example\n * the following Stylus:\n *\n *    ul\n *      li\n *      p\n *        a\n *          color: red\n *\n * Would return:\n *\n *      [ 'ul li a', 'ul p a' ]\n *\n * @param {Array} arr\n * @param {Boolean} leaveHidden\n * @return {Array}\n * @api private\n */\n\nexports.compileSelectors = function (arr, leaveHidden) {\n  var selectors = [],\n    Parser = require('./selector-parser'),\n    indent = this.indent || '',\n    buf = [];\n  function parse(selector, buf) {\n    var parts = [selector.val],\n      str = new Parser(parts[0], parents, parts).parse().val,\n      parents = [];\n    if (buf.length) {\n      for (var i = 0, len = buf.length; i < len; ++i) {\n        parts.push(buf[i]);\n        parents.push(str);\n        var child = new Parser(buf[i], parents, parts).parse();\n        if (child.nested) {\n          str += ' ' + child.val;\n        } else {\n          str = child.val;\n        }\n      }\n    }\n    return str.trim();\n  }\n  function compile(arr, i) {\n    if (i) {\n      arr[i].forEach(function (selector) {\n        if (!leaveHidden && selector.isPlaceholder) return;\n        if (selector.inherits) {\n          buf.unshift(selector.val);\n          compile(arr, i - 1);\n          buf.shift();\n        } else {\n          selectors.push(indent + parse(selector, buf));\n        }\n      });\n    } else {\n      arr[0].forEach(function (selector) {\n        if (!leaveHidden && selector.isPlaceholder) return;\n        var str = parse(selector, buf);\n        if (str) selectors.push(indent + str);\n      });\n    }\n  }\n  compile(arr, arr.length - 1);\n\n  // Return the list with unique selectors only\n  return exports.uniq(selectors);\n};\n\n/**\n * Attempt to parse string.\n *\n * @param {String} str\n * @return {Node}\n * @api private\n */\n\nexports.parseString = function (str) {\n  var Parser = require('./parser'),\n    parser,\n    ret;\n  try {\n    parser = new Parser(str);\n    ret = parser.list();\n  } catch (e) {\n    ret = new nodes.Literal(str);\n  }\n  return ret;\n};","map":{"version":3,"names":["nodes","require","basename","relative","join","isAbsolute","glob","fs","exports","absolute","path","substr","charAt","test","lookup","paths","ignore","i","length","statSync","err","find","found","sync","lookupIndex","name","filename","replace","indexOf","lookupPackage","dir","pkg","main","__dirname","formatException","options","lineno","column","str","input","context","lines","split","start","Math","max","end","min","pad","toString","slice","map","line","curr","Array","message","stylusStack","fromStylus","stack","assertType","node","type","param","assertPresent","nodeName","actual","msg","Error","assertString","assertColor","unwrap","expr","preserve","coerce","val","raw","String","Boolean","Unit","null","isArray","coerceArray","coerceObject","Expression","forEach","push","obj","Object","key","Ident","set","params","fn","match","merge","a","b","deep","k","nodeA","first","nodeB","vals","uniq","arr","ret","len","compileSelectors","leaveHidden","selectors","Parser","indent","buf","parse","selector","parts","parents","child","nested","trim","compile","isPlaceholder","inherits","unshift","shift","parseString","parser","list","e","Literal"],"sources":["/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/stylus/lib/utils.js"],"sourcesContent":["\n/*!\n * Stylus - utils\n * Copyright (c) Automattic <developer.wordpress.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar nodes = require('./nodes')\n  , basename = require('path').basename\n  , relative = require('path').relative\n  , join = require('path').join\n  , isAbsolute = require('path').isAbsolute\n  , glob = require('glob')\n  , fs = require('fs');\n\n/**\n * Check if `path` looks absolute.\n *\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nexports.absolute = isAbsolute || function(path){\n  // On Windows the path could start with a drive letter, i.e. a:\\\\ or two leading backslashes.\n  // Also on Windows, the path may have been normalized to forward slashes, so check for this too.\n  return path.substr(0, 2) == '\\\\\\\\' || '/' === path.charAt(0) || /^[a-z]:[\\\\\\/]/i.test(path);\n};\n\n/**\n * Attempt to lookup `path` within `paths` from tail to head.\n * Optionally a path to `ignore` may be passed.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {String}\n * @api private\n */\n\nexports.lookup = function(path, paths, ignore){\n  var lookup\n    , i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    try {\n      fs.statSync(path);\n      return path;\n    } catch (err) {\n      // Ignore, continue on\n      // to trying relative lookup.\n      // Needed for url(/images/foo.png)\n      // for example\n    }\n  }\n\n  // Relative\n  while (i--) {\n    try {\n      lookup = join(paths[i], path);\n      if (ignore == lookup) continue;\n      fs.statSync(lookup);\n      return lookup;\n    } catch (err) {\n      // Ignore\n    }\n  }\n};\n\n/**\n * Like `utils.lookup` but uses `glob` to find files.\n *\n * @param {String} path\n * @param {String} paths\n * @param {String} ignore\n * @return {Array}\n * @api private\n */\nexports.find = function(path, paths, ignore) {\n  var lookup\n    , found\n    , i = paths.length;\n\n  // Absolute\n  if (exports.absolute(path)) {\n    if ((found = glob.sync(path)).length) {\n      return found;\n    }\n  }\n\n  // Relative\n  while (i--) {\n    lookup = join(paths[i], path);\n    if (ignore == lookup) continue;\n    if ((found = glob.sync(lookup)).length) {\n      return found;\n    }\n  }\n};\n\n/**\n * Lookup index file inside dir with given `name`.\n *\n * @param {String} name\n * @return {Array}\n * @api private\n */\n\nexports.lookupIndex = function(name, paths, filename){\n  // foo/index.styl\n  var found = exports.find(join(name, 'index.styl'), paths, filename);\n  if (!found) {\n    // foo/foo.styl\n    found = exports.find(join(name, basename(name).replace(/\\.styl/i, '') + '.styl'), paths, filename);\n  }\n  if (!found && !~name.indexOf('node_modules')) {\n    // node_modules/foo/.. or node_modules/foo.styl/..\n    found = lookupPackage(join('node_modules', name));\n  }\n  return found;\n\n  function lookupPackage(dir) {\n    var pkg = exports.lookup(join(dir, 'package.json'), paths, filename);\n    if (!pkg) {\n      return /\\.styl$/i.test(dir) ? exports.lookupIndex(dir, paths, filename) : lookupPackage(dir + '.styl');\n    }\n    var main = require(relative(__dirname, pkg)).main;\n    if (main) {\n      found = exports.find(join(dir, main), paths, filename);\n    } else {\n      found = exports.lookupIndex(dir, paths, filename);\n    }\n    return found;\n  }\n};\n\n/**\n * Format the given `err` with the given `options`.\n *\n * Options:\n *\n *   - `filename`   context filename\n *   - `context`    context line count [8]\n *   - `lineno`     context line number\n *   - `column`     context column number\n *   - `input`        input string\n *\n * @param {Error} err\n * @param {Object} options\n * @return {Error}\n * @api private\n */\n\nexports.formatException = function(err, options){\n  var lineno = options.lineno\n    , column = options.column\n    , filename = options.filename\n    , str = options.input\n    , context = options.context || 8\n    , context = context / 2\n    , lines = ('\\n' + str).split('\\n')\n    , start = Math.max(lineno - context, 1)\n    , end = Math.min(lines.length, lineno + context)\n    , pad = end.toString().length;\n\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start;\n    return '   '\n      + Array(pad - curr.toString().length + 1).join(' ')\n      + curr\n      + '| '\n      + line\n      + (curr == lineno\n        ? '\\n' + Array(curr.toString().length + 5 + column).join('-') + '^'\n        : '');\n  }).join('\\n');\n\n  err.message = filename\n    + ':' + lineno\n    + ':' + column\n    + '\\n' + context\n    + '\\n\\n' + err.message + '\\n'\n    + (err.stylusStack ? err.stylusStack + '\\n' : '');\n\n  // Don't show JS stack trace for Stylus errors\n  if (err.fromStylus) err.stack = 'Error: ' + err.message;\n\n  return err;\n};\n\n/**\n * Assert that `node` is of the given `type`, or throw.\n *\n * @param {Node} node\n * @param {Function} type\n * @param {String} param\n * @api public\n */\n\nexports.assertType = function(node, type, param){\n  exports.assertPresent(node, param);\n  if (node.nodeName == type) return;\n  var actual = node.nodeName\n    , msg = 'expected '\n      + (param ? '\"' + param + '\" to be a ' :  '')\n      + type + ', but got '\n      + actual + ':' + node;\n  throw new Error('TypeError: ' + msg);\n};\n\n/**\n * Assert that `node` is a `String` or `Ident`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertString = function(node, param){\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'string':\n    case 'ident':\n    case 'literal':\n      return;\n    default:\n      var actual = node.nodeName\n        , msg = 'expected string, ident or literal, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that `node` is a `RGBA` or `HSLA`.\n *\n * @param {Node} node\n * @param {String} param\n * @api public\n */\n\nexports.assertColor = function(node, param){\n  exports.assertPresent(node, param);\n  switch (node.nodeName) {\n    case 'rgba':\n    case 'hsla':\n      return;\n    default:\n      var actual = node.nodeName\n        , msg = 'expected rgba or hsla, but got ' + actual + ':' + node;\n      throw new Error('TypeError: ' + msg);\n  }\n};\n\n/**\n * Assert that param `name` is given, aka the `node` is passed.\n *\n * @param {Node} node\n * @param {String} name\n * @api public\n */\n\nexports.assertPresent = function(node, name){\n  if (node) return;\n  if (name) throw new Error('\"' + name + '\" argument required');\n  throw new Error('argument missing');\n};\n\n/**\n * Unwrap `expr`.\n *\n * Takes an expressions with length of 1\n * such as `((1 2 3))` and unwraps it to `(1 2 3)`.\n *\n * @param {Expression} expr\n * @return {Node}\n * @api public\n */\n\nexports.unwrap = function(expr){\n  // explicitly preserve the expression\n  if (expr.preserve) return expr;\n  if ('arguments' != expr.nodeName && 'expression' != expr.nodeName) return expr;\n  if (1 != expr.nodes.length) return expr;\n  if ('arguments' != expr.nodes[0].nodeName && 'expression' != expr.nodes[0].nodeName) return expr;\n  return exports.unwrap(expr.nodes[0]);\n};\n\n/**\n * Coerce JavaScript values to their Stylus equivalents.\n *\n * @param {Mixed} val\n * @param {Boolean} [raw]\n * @return {Node}\n * @api public\n */\n\nexports.coerce = function(val, raw){\n  switch (typeof val) {\n    case 'function':\n      return val;\n    case 'string':\n      return new nodes.String(val);\n    case 'boolean':\n      return new nodes.Boolean(val);\n    case 'number':\n      return new nodes.Unit(val);\n    default:\n      if (null == val) return nodes.null;\n      if (Array.isArray(val)) return exports.coerceArray(val, raw);\n      if (val.nodeName) return val;\n      return exports.coerceObject(val, raw);\n  }\n};\n\n/**\n * Coerce a javascript `Array` to a Stylus `Expression`.\n *\n * @param {Array} val\n * @param {Boolean} [raw]\n * @return {Expression}\n * @api private\n */\n\nexports.coerceArray = function(val, raw){\n  var expr = new nodes.Expression;\n  val.forEach(function(val){\n    expr.push(exports.coerce(val, raw));\n  });\n  return expr;\n};\n\n/**\n * Coerce a javascript object to a Stylus `Expression` or `Object`.\n *\n * For example `{ foo: 'bar', bar: 'baz' }` would become\n * the expression `(foo 'bar') (bar 'baz')`. If `raw` is true\n * given `obj` would become a Stylus hash object.\n *\n * @param {Object} obj\n * @param {Boolean} [raw]\n * @return {Expression|Object}\n * @api public\n */\n\nexports.coerceObject = function(obj, raw){\n  var node = raw ? new nodes.Object : new nodes.Expression\n    , val;\n\n  for (var key in obj) {\n    val = exports.coerce(obj[key], raw);\n    key = new nodes.Ident(key);\n    if (raw) {\n      node.set(key, val);\n    } else {\n      node.push(exports.coerceArray([key, val]));\n    }\n  }\n\n  return node;\n};\n\n/**\n * Return param names for `fn`.\n *\n * @param {Function} fn\n * @return {Array}\n * @api private\n */\n\nexports.params = function(fn){\n  return fn\n    .toString()\n    .match(/\\(([^)]*)\\)/)[1].split(/ *, */);\n};\n\n/**\n * Merge object `b` with `a`.\n *\n * @param {Object} a\n * @param {Object} b\n * @param {Boolean} [deep]\n * @return {Object} a\n * @api private\n */\nexports.merge = function(a, b, deep) {\n  for (var k in b) {\n    if (deep && a[k]) {\n      var nodeA = exports.unwrap(a[k]).first\n        , nodeB = exports.unwrap(b[k]).first;\n\n      if ('object' == nodeA.nodeName && 'object' == nodeB.nodeName) {\n        a[k].first.vals = exports.merge(nodeA.vals, nodeB.vals, deep);\n      } else {\n        a[k] = b[k];\n      }\n    } else {\n      a[k] = b[k];\n    }\n  }\n  return a;\n};\n\n/**\n * Returns an array with unique values.\n *\n * @param {Array} arr\n * @return {Array}\n * @api private\n */\n\nexports.uniq = function(arr){\n  var obj = {}\n    , ret = [];\n\n  for (var i = 0, len = arr.length; i < len; ++i) {\n    if (arr[i] in obj) continue;\n\n    obj[arr[i]] = true;\n    ret.push(arr[i]);\n  }\n  return ret;\n};\n\n/**\n * Compile selector strings in `arr` from the bottom-up\n * to produce the selector combinations. For example\n * the following Stylus:\n *\n *    ul\n *      li\n *      p\n *        a\n *          color: red\n *\n * Would return:\n *\n *      [ 'ul li a', 'ul p a' ]\n *\n * @param {Array} arr\n * @param {Boolean} leaveHidden\n * @return {Array}\n * @api private\n */\n\nexports.compileSelectors = function(arr, leaveHidden){\n  var selectors = []\n    , Parser = require('./selector-parser')\n    , indent = (this.indent || '')\n    , buf = [];\n\n  function parse(selector, buf) {\n    var parts = [selector.val]\n      , str = new Parser(parts[0], parents, parts).parse().val\n      , parents = [];\n\n    if (buf.length) {\n      for (var i = 0, len = buf.length; i < len; ++i) {\n        parts.push(buf[i]);\n        parents.push(str);\n        var child = new Parser(buf[i], parents, parts).parse();\n\n        if (child.nested) {\n          str += ' ' + child.val;\n        } else {\n          str = child.val;\n        }\n      }\n    }\n    return str.trim();\n  }\n\n  function compile(arr, i) {\n    if (i) {\n      arr[i].forEach(function(selector){\n        if (!leaveHidden && selector.isPlaceholder) return;\n        if (selector.inherits) {\n          buf.unshift(selector.val);\n          compile(arr, i - 1);\n          buf.shift();\n        } else {\n          selectors.push(indent + parse(selector, buf));\n        }\n      });\n    } else {\n      arr[0].forEach(function(selector){\n        if (!leaveHidden && selector.isPlaceholder) return;\n        var str = parse(selector, buf);\n        if (str) selectors.push(indent + str);\n      });\n    }\n  }\n\n  compile(arr, arr.length - 1);\n\n  // Return the list with unique selectors only\n  return exports.uniq(selectors);\n};\n\n/**\n * Attempt to parse string.\n *\n * @param {String} str\n * @return {Node}\n * @api private\n */\n\nexports.parseString = function(str){\n  var Parser = require('./parser')\n    , parser\n    , ret;\n\n  try {\n    parser = new Parser(str);\n    ret = parser.list();\n  } catch (e) {\n    ret = new nodes.Literal(str);\n  }\n  return ret;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}