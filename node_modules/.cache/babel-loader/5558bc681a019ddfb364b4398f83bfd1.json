{"ast":null,"code":"var _possibleConstructorReturn = require(\"/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\").default;\nvar _inherits = require(\"/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _regeneratorRuntime = require(\"/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/@babel/runtime/helpers/createClass.js\").default;\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require(\"./util\");\nvar binarySearch = require(\"./binary-search\");\nvar ArraySet = require(\"./array-set\").ArraySet;\nvar base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nvar readWasm = require(\"../lib/read-wasm\");\nvar wasm = require(\"./wasm\");\nvar INTERNAL = Symbol(\"smcInternal\");\nvar SourceMapConsumer = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function SourceMapConsumer(aSourceMap, aSourceMapURL) {\n    _classCallCheck(this, SourceMapConsumer);\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n  _createClass(SourceMapConsumer, [{\n    key: \"_parseMappings\",\n    value:\n    /**\n     * Parse the mappings in a string in to a data structure which we can easily\n     * query (the ordered arrays in the `this.__generatedMappings` and\n     * `this.__originalMappings` properties).\n     */\n    function _parseMappings(aStr, aSourceRoot) {\n      throw new Error(\"Subclasses must implement _parseMappings\");\n    }\n\n    /**\n     * Iterate over each mapping between an original source/line/column and a\n     * generated line/column in this source map.\n     *\n     * @param Function aCallback\n     *        The function that is called with each mapping.\n     * @param Object aContext\n     *        Optional. If specified, this object will be the value of `this` every\n     *        time that `aCallback` is called.\n     * @param aOrder\n     *        Either `SourceMapConsumer.GENERATED_ORDER` or\n     *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n     *        iterate over the mappings sorted by the generated file's line/column\n     *        order or the original's source/line/column order, respectively. Defaults to\n     *        `SourceMapConsumer.GENERATED_ORDER`.\n     */\n  }, {\n    key: \"eachMapping\",\n    value: function eachMapping(aCallback, aContext, aOrder) {\n      throw new Error(\"Subclasses must implement eachMapping\");\n    }\n\n    /**\n     * Returns all generated line and column information for the original source,\n     * line, and column provided. If no column is provided, returns all mappings\n     * corresponding to a either the line we are searching for or the next\n     * closest line that has any mappings. Otherwise, returns all mappings\n     * corresponding to the given line and either the column we are searching for\n     * or the next closest column that has any offsets.\n     *\n     * The only argument is an object with the following properties:\n     *\n     *   - source: The filename of the original source.\n     *   - line: The line number in the original source.  The line number is 1-based.\n     *   - column: Optional. the column number in the original source.\n     *    The column number is 0-based.\n     *\n     * and an array of objects is returned, each with the following properties:\n     *\n     *   - line: The line number in the generated source, or null.  The\n     *    line number is 1-based.\n     *   - column: The column number in the generated source, or null.\n     *    The column number is 0-based.\n     */\n  }, {\n    key: \"allGeneratedPositionsFor\",\n    value: function allGeneratedPositionsFor(aArgs) {\n      throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      throw new Error(\"Subclasses must implement destroy\");\n    }\n  }], [{\n    key: \"initialize\",\n    value: function initialize(opts) {\n      readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n    }\n  }, {\n    key: \"fromSourceMap\",\n    value: function fromSourceMap(aSourceMap, aSourceMapURL) {\n      return _factoryBSM(aSourceMap, aSourceMapURL);\n    }\n\n    /**\n     * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n     * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n     * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n     * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n     * value.\n     *\n     * You must not use the consumer after `f` completes!\n     *\n     * By using `with`, you do not have to remember to manually call `destroy` on\n     * the consumer, since it will be called automatically once `f` completes.\n     *\n     * ```js\n     * const xSquared = await SourceMapConsumer.with(\n     *   myRawSourceMap,\n     *   null,\n     *   async function (consumer) {\n     *     // Use `consumer` inside here and don't worry about remembering\n     *     // to call `destroy`.\n     *\n     *     const x = await whatever(consumer);\n     *     return x * x;\n     *   }\n     * );\n     *\n     * // You may not use that `consumer` anymore out here; it has\n     * // been destroyed. But you can use `xSquared`.\n     * console.log(xSquared);\n     * ```\n     */\n  }, {\n    key: \"with\",\n    value: function () {\n      var _with2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(rawSourceMap, sourceMapUrl, f) {\n        var consumer;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n            case 2:\n              consumer = _context.sent;\n              _context.prev = 3;\n              _context.next = 6;\n              return f(consumer);\n            case 6:\n              return _context.abrupt(\"return\", _context.sent);\n            case 7:\n              _context.prev = 7;\n              consumer.destroy();\n              return _context.finish(7);\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[3,, 7, 10]]);\n      }));\n      function _with(_x, _x2, _x3) {\n        return _with2.apply(this, arguments);\n      }\n      return _with;\n    }()\n  }]);\n  return SourceMapConsumer;\n}();\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nvar BasicSourceMapConsumer = /*#__PURE__*/function (_SourceMapConsumer) {\n  \"use strict\";\n\n  _inherits(BasicSourceMapConsumer, _SourceMapConsumer);\n  var _super = _createSuper(BasicSourceMapConsumer);\n  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var _this;\n    _classCallCheck(this, BasicSourceMapConsumer);\n    return _possibleConstructorReturn(_this, (_this = _super.call(this, INTERNAL)).then(function (that) {\n      var sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n      var version = util.getArg(sourceMap, \"version\");\n      var sources = util.getArg(sourceMap, \"sources\");\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      var names = util.getArg(sourceMap, \"names\", []);\n      var sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      var sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      var mappings = util.getArg(sourceMap, \"mappings\");\n      var file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n      sources = sources.map(String)\n      // Some source maps produce relative source paths like \"./foo.js\" instead of\n      // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n      // See bugzil.la/1090768.\n      .map(util.normalize)\n      // Always ensure that absolute sources are internally stored relative to\n      // the source root, if the source root is absolute. Not doing this would\n      // be particularly problematic when the source root is a prefix of the\n      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n      .map(function (source) {\n        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;\n      });\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n      that._absoluteSources = that._sources.toArray().map(function (s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n      return wasm().then(function (w) {\n        that._wasm = w;\n        return that;\n      });\n    }));\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _createClass(BasicSourceMapConsumer, [{\n    key: \"_findSourceIndex\",\n    value: function _findSourceIndex(aSource) {\n      var relativeSource = aSource;\n      if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n      }\n      if (this._sources.has(relativeSource)) {\n        return this._sources.indexOf(relativeSource);\n      }\n\n      // Maybe aSource is an absolute URL as returned by |sources|.  In\n      // this case we can't simply undo the transform.\n      for (var i = 0; i < this._absoluteSources.length; ++i) {\n        if (this._absoluteSources[i] == aSource) {\n          return i;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n     *\n     * @param SourceMapGenerator aSourceMap\n     *        The source map that will be consumed.\n     * @param String aSourceMapURL\n     *        The URL at which the source map can be found (optional)\n     * @returns BasicSourceMapConsumer\n     */\n  }, {\n    key: \"sources\",\n    get: function get() {\n      return this._absoluteSources.slice();\n    }\n  }, {\n    key: \"_getMappingsPtr\",\n    value: function _getMappingsPtr() {\n      if (this._mappingsPtr === 0) {\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n      return this._mappingsPtr;\n    }\n\n    /**\n     * Parse the mappings in a string in to a data structure which we can easily\n     * query (the ordered arrays in the `this.__generatedMappings` and\n     * `this.__originalMappings` properties).\n     */\n  }, {\n    key: \"_parseMappings\",\n    value: function _parseMappings(aStr, aSourceRoot) {\n      var size = aStr.length;\n      var mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n      var mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n      for (var i = 0; i < size; i++) {\n        mappingsBuf[i] = aStr.charCodeAt(i);\n      }\n      var mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n      if (!mappingsPtr) {\n        var error = this._wasm.exports.get_last_error();\n        var msg = \"Error parsing mappings (code \".concat(error, \"): \");\n\n        // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n        switch (error) {\n          case 1:\n            msg += \"the mappings contained a negative line, column, source index, or name index\";\n            break;\n          case 2:\n            msg += \"the mappings contained a number larger than 2**32\";\n            break;\n          case 3:\n            msg += \"reached EOF while in the middle of parsing a VLQ\";\n            break;\n          case 4:\n            msg += \"invalid base 64 character while parsing a VLQ\";\n            break;\n          default:\n            msg += \"unknown error code\";\n            break;\n        }\n        throw new Error(msg);\n      }\n      this._mappingsPtr = mappingsPtr;\n    }\n  }, {\n    key: \"eachMapping\",\n    value: function eachMapping(aCallback, aContext, aOrder) {\n      var _this2 = this;\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n      var sourceRoot = this.sourceRoot;\n      this._wasm.withMappingCallback(function (mapping) {\n        if (mapping.source !== null) {\n          mapping.source = _this2._sources.at(mapping.source);\n          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, _this2._sourceMapURL);\n          if (mapping.name !== null) {\n            mapping.name = _this2._names.at(mapping.name);\n          }\n        }\n        aCallback.call(context, mapping);\n      }, function () {\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            _this2._wasm.exports.by_generated_location(_this2._getMappingsPtr());\n            break;\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            _this2._wasm.exports.by_original_location(_this2._getMappingsPtr());\n            break;\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n      });\n    }\n  }, {\n    key: \"allGeneratedPositionsFor\",\n    value: function allGeneratedPositionsFor(aArgs) {\n      var _this3 = this;\n      var source = util.getArg(aArgs, \"source\");\n      var originalLine = util.getArg(aArgs, \"line\");\n      var originalColumn = aArgs.column || 0;\n      source = this._findSourceIndex(source);\n      if (source < 0) {\n        return [];\n      }\n      if (originalLine < 1) {\n        throw new Error(\"Line numbers must be >= 1\");\n      }\n      if (originalColumn < 0) {\n        throw new Error(\"Column numbers must be >= 0\");\n      }\n      var mappings = [];\n      this._wasm.withMappingCallback(function (m) {\n        var lastColumn = m.lastGeneratedColumn;\n        if (_this3._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn: lastColumn\n        });\n      }, function () {\n        _this3._wasm.exports.all_generated_locations_for(_this3._getMappingsPtr(), source, originalLine - 1, \"column\" in aArgs, originalColumn);\n      });\n      return mappings;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._mappingsPtr !== 0) {\n        this._wasm.exports.free_mappings(this._mappingsPtr);\n        this._mappingsPtr = 0;\n      }\n    }\n\n    /**\n     * Compute the last column for each generated mapping. The last column is\n     * inclusive.\n     */\n  }, {\n    key: \"computeColumnSpans\",\n    value: function computeColumnSpans() {\n      if (this._computedColumnSpans) {\n        return;\n      }\n      this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n      this._computedColumnSpans = true;\n    }\n\n    /**\n     * Returns the original source, line, and column information for the generated\n     * source's line and column positions provided. The only argument is an object\n     * with the following properties:\n     *\n     *   - line: The line number in the generated source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the generated source.  The column\n     *     number is 0-based.\n     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n     *     closest element that is smaller than or greater than the one we are\n     *     searching for, respectively, if the exact element cannot be found.\n     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - source: The original source file, or null.\n     *   - line: The line number in the original source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the original source, or null.  The\n     *     column number is 0-based.\n     *   - name: The original identifier, or null.\n     */\n  }, {\n    key: \"originalPositionFor\",\n    value: function originalPositionFor(aArgs) {\n      var _this4 = this;\n      var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n      };\n      if (needle.generatedLine < 1) {\n        throw new Error(\"Line numbers must be >= 1\");\n      }\n      if (needle.generatedColumn < 0) {\n        throw new Error(\"Column numbers must be >= 0\");\n      }\n      var bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n      if (bias == null) {\n        bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n      }\n      var mapping;\n      this._wasm.withMappingCallback(function (m) {\n        return mapping = m;\n      }, function () {\n        _this4._wasm.exports.original_location_for(_this4._getMappingsPtr(), needle.generatedLine - 1, needle.generatedColumn, bias);\n      });\n      if (mapping) {\n        if (mapping.generatedLine === needle.generatedLine) {\n          var source = util.getArg(mapping, \"source\", null);\n          if (source !== null) {\n            source = this._sources.at(source);\n            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n          }\n          var name = util.getArg(mapping, \"name\", null);\n          if (name !== null) {\n            name = this._names.at(name);\n          }\n          return {\n            source: source,\n            line: util.getArg(mapping, \"originalLine\", null),\n            column: util.getArg(mapping, \"originalColumn\", null),\n            name: name\n          };\n        }\n      }\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    /**\n     * Return true if we have the source content for every source in the source\n     * map, false otherwise.\n     */\n  }, {\n    key: \"hasContentsOfAllSources\",\n    value: function hasContentsOfAllSources() {\n      if (!this.sourcesContent) {\n        return false;\n      }\n      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {\n        return sc == null;\n      });\n    }\n\n    /**\n     * Returns the original source content. The only argument is the url of the\n     * original source file. Returns null if no original source content is\n     * available.\n     */\n  }, {\n    key: \"sourceContentFor\",\n    value: function sourceContentFor(aSource, nullOnMissing) {\n      if (!this.sourcesContent) {\n        return null;\n      }\n      var index = this._findSourceIndex(aSource);\n      if (index >= 0) {\n        return this.sourcesContent[index];\n      }\n      var relativeSource = aSource;\n      if (this.sourceRoot != null) {\n        relativeSource = util.relative(this.sourceRoot, relativeSource);\n      }\n      var url;\n      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n        // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n        // many users. We can help them out when they expect file:// URIs to\n        // behave like it would if they were running a local HTTP server. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n        var fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n        if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n        }\n        if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + relativeSource)) {\n          return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n        }\n      }\n\n      // This function is used recursively from\n      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n      // don't want to throw if we can't find the source - we just want to\n      // return null, so we provide a flag to exit gracefully.\n      if (nullOnMissing) {\n        return null;\n      }\n      throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n    }\n\n    /**\n     * Returns the generated line and column information for the original source,\n     * line, and column positions provided. The only argument is an object with\n     * the following properties:\n     *\n     *   - source: The filename of the original source.\n     *   - line: The line number in the original source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the original source.  The column\n     *     number is 0-based.\n     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n     *     closest element that is smaller than or greater than the one we are\n     *     searching for, respectively, if the exact element cannot be found.\n     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - line: The line number in the generated source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the generated source, or null.\n     *     The column number is 0-based.\n     */\n  }, {\n    key: \"generatedPositionFor\",\n    value: function generatedPositionFor(aArgs) {\n      var _this5 = this;\n      var source = util.getArg(aArgs, \"source\");\n      source = this._findSourceIndex(source);\n      if (source < 0) {\n        return {\n          line: null,\n          column: null,\n          lastColumn: null\n        };\n      }\n      var needle = {\n        source: source,\n        originalLine: util.getArg(aArgs, \"line\"),\n        originalColumn: util.getArg(aArgs, \"column\")\n      };\n      if (needle.originalLine < 1) {\n        throw new Error(\"Line numbers must be >= 1\");\n      }\n      if (needle.originalColumn < 0) {\n        throw new Error(\"Column numbers must be >= 0\");\n      }\n      var bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n      if (bias == null) {\n        bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n      }\n      var mapping;\n      this._wasm.withMappingCallback(function (m) {\n        return mapping = m;\n      }, function () {\n        _this5._wasm.exports.generated_location_for(_this5._getMappingsPtr(), needle.source, needle.originalLine - 1, needle.originalColumn, bias);\n      });\n      if (mapping) {\n        if (mapping.source === needle.source) {\n          var lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          return {\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn: lastColumn\n          };\n        }\n      }\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n  }], [{\n    key: \"fromSourceMap\",\n    value: function fromSourceMap(aSourceMap, aSourceMapURL) {\n      return new BasicSourceMapConsumer(aSourceMap.toString());\n    }\n  }]);\n  return BasicSourceMapConsumer;\n}(SourceMapConsumer);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nvar IndexedSourceMapConsumer = /*#__PURE__*/function (_SourceMapConsumer2) {\n  \"use strict\";\n\n  _inherits(IndexedSourceMapConsumer, _SourceMapConsumer2);\n  var _super2 = _createSuper(IndexedSourceMapConsumer);\n  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {\n    var _this6;\n    _classCallCheck(this, IndexedSourceMapConsumer);\n    return _possibleConstructorReturn(_this6, (_this6 = _super2.call(this, INTERNAL)).then(function (that) {\n      var sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n      var version = util.getArg(sourceMap, \"version\");\n      var sections = util.getArg(sourceMap, \"sections\");\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n      var lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(function (s) {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        var offset = util.getArg(s, \"offset\");\n        var offsetLine = util.getArg(offset, \"line\");\n        var offsetColumn = util.getArg(offset, \"column\");\n        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n        var cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(function (consumer) {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer: consumer\n          };\n        });\n      })).then(function (s) {\n        that._sections = s;\n        return that;\n      });\n    }));\n  }\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n  _createClass(IndexedSourceMapConsumer, [{\n    key: \"_generatedMappings\",\n    get: function get() {\n      if (!this.__generatedMappings) {\n        this._sortGeneratedMappings();\n      }\n      return this.__generatedMappings;\n    }\n  }, {\n    key: \"_originalMappings\",\n    get: function get() {\n      if (!this.__originalMappings) {\n        this._sortOriginalMappings();\n      }\n      return this.__originalMappings;\n    }\n  }, {\n    key: \"_generatedMappingsUnsorted\",\n    get: function get() {\n      if (!this.__generatedMappingsUnsorted) {\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n      return this.__generatedMappingsUnsorted;\n    }\n  }, {\n    key: \"_originalMappingsUnsorted\",\n    get: function get() {\n      if (!this.__originalMappingsUnsorted) {\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n      return this.__originalMappingsUnsorted;\n    }\n  }, {\n    key: \"_sortGeneratedMappings\",\n    value: function _sortGeneratedMappings() {\n      var mappings = this._generatedMappingsUnsorted;\n      mappings.sort(util.compareByGeneratedPositionsDeflated);\n      this.__generatedMappings = mappings;\n    }\n  }, {\n    key: \"_sortOriginalMappings\",\n    value: function _sortOriginalMappings() {\n      var mappings = this._originalMappingsUnsorted;\n      mappings.sort(util.compareByOriginalPositions);\n      this.__originalMappings = mappings;\n    }\n\n    /**\n     * The list of original sources.\n     */\n  }, {\n    key: \"sources\",\n    get: function get() {\n      var sources = [];\n      for (var i = 0; i < this._sections.length; i++) {\n        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n          sources.push(this._sections[i].consumer.sources[j]);\n        }\n      }\n      return sources;\n    }\n\n    /**\n     * Returns the original source, line, and column information for the generated\n     * source's line and column positions provided. The only argument is an object\n     * with the following properties:\n     *\n     *   - line: The line number in the generated source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the generated source.  The column\n     *     number is 0-based.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - source: The original source file, or null.\n     *   - line: The line number in the original source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the original source, or null.  The\n     *     column number is 0-based.\n     *   - name: The original identifier, or null.\n     */\n  }, {\n    key: \"originalPositionFor\",\n    value: function originalPositionFor(aArgs) {\n      var needle = {\n        generatedLine: util.getArg(aArgs, \"line\"),\n        generatedColumn: util.getArg(aArgs, \"column\")\n      };\n\n      // Find the section containing the generated position we're trying to map\n      // to an original position.\n      var sectionIndex = binarySearch.search(needle, this._sections, function (aNeedle, section) {\n        var cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n        return aNeedle.generatedColumn - section.generatedOffset.generatedColumn;\n      });\n      var section = this._sections[sectionIndex];\n      if (!section) {\n        return {\n          source: null,\n          line: null,\n          column: null,\n          name: null\n        };\n      }\n      return section.consumer.originalPositionFor({\n        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n        bias: aArgs.bias\n      });\n    }\n\n    /**\n     * Return true if we have the source content for every source in the source\n     * map, false otherwise.\n     */\n  }, {\n    key: \"hasContentsOfAllSources\",\n    value: function hasContentsOfAllSources() {\n      return this._sections.every(function (s) {\n        return s.consumer.hasContentsOfAllSources();\n      });\n    }\n\n    /**\n     * Returns the original source content. The only argument is the url of the\n     * original source file. Returns null if no original source content is\n     * available.\n     */\n  }, {\n    key: \"sourceContentFor\",\n    value: function sourceContentFor(aSource, nullOnMissing) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n        var content = section.consumer.sourceContentFor(aSource, true);\n        if (content) {\n          return content;\n        }\n      }\n      if (nullOnMissing) {\n        return null;\n      }\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n\n    /**\n     * Returns the generated line and column information for the original source,\n     * line, and column positions provided. The only argument is an object with\n     * the following properties:\n     *\n     *   - source: The filename of the original source.\n     *   - line: The line number in the original source.  The line number\n     *     is 1-based.\n     *   - column: The column number in the original source.  The column\n     *     number is 0-based.\n     *\n     * and an object is returned with the following properties:\n     *\n     *   - line: The line number in the generated source, or null.  The\n     *     line number is 1-based.\n     *   - column: The column number in the generated source, or null.\n     *     The column number is 0-based.\n     */\n  }, {\n    key: \"generatedPositionFor\",\n    value: function generatedPositionFor(aArgs) {\n      for (var i = 0; i < this._sections.length; i++) {\n        var section = this._sections[i];\n\n        // Only consider this section if the requested source is in the list of\n        // sources of the consumer.\n        if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n          continue;\n        }\n        var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n        if (generatedPosition) {\n          var ret = {\n            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),\n            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)\n          };\n          return ret;\n        }\n      }\n      return {\n        line: null,\n        column: null\n      };\n    }\n\n    /**\n     * Parse the mappings in a string in to a data structure which we can easily\n     * query (the ordered arrays in the `this.__generatedMappings` and\n     * `this.__originalMappings` properties).\n     */\n  }, {\n    key: \"_parseMappings\",\n    value: function _parseMappings(aStr, aSourceRoot) {\n      var _this7 = this;\n      var generatedMappings = this.__generatedMappingsUnsorted = [];\n      var originalMappings = this.__originalMappingsUnsorted = [];\n      var _loop = function _loop() {\n        var section = _this7._sections[i];\n        var sectionMappings = [];\n        section.consumer.eachMapping(function (m) {\n          return sectionMappings.push(m);\n        });\n        for (var j = 0; j < sectionMappings.length; j++) {\n          var mapping = sectionMappings[j];\n\n          // TODO: test if null is correct here.  The original code used\n          // `source`, which would actually have gotten used as null because\n          // var's get hoisted.\n          // See: https://github.com/mozilla/source-map/issues/333\n          var source = util.computeSourceURL(section.consumer.sourceRoot, null, _this7._sourceMapURL);\n          _this7._sources.add(source);\n          source = _this7._sources.indexOf(source);\n          var name = null;\n          if (mapping.name) {\n            _this7._names.add(mapping.name);\n            name = _this7._names.indexOf(mapping.name);\n          }\n\n          // The mappings coming from the consumer for the section have\n          // generated positions relative to the start of the section, so we\n          // need to offset them to be relative to the start of the concatenated\n          // generated file.\n          var adjustedMapping = {\n            source: source,\n            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),\n            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),\n            originalLine: mapping.originalLine,\n            originalColumn: mapping.originalColumn,\n            name: name\n          };\n          generatedMappings.push(adjustedMapping);\n          if (typeof adjustedMapping.originalLine === \"number\") {\n            originalMappings.push(adjustedMapping);\n          }\n        }\n      };\n      for (var i = 0; i < this._sections.length; i++) {\n        _loop();\n      }\n    }\n  }, {\n    key: \"eachMapping\",\n    value: function eachMapping(aCallback, aContext, aOrder) {\n      var context = aContext || null;\n      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n      var mappings;\n      switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          mappings = this._generatedMappings;\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          mappings = this._originalMappings;\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n      }\n      var sourceRoot = this.sourceRoot;\n      mappings.map(function (mapping) {\n        var source = null;\n        if (mapping.source !== null) {\n          source = this._sources.at(mapping.source);\n          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n        }\n        return {\n          source: source,\n          generatedLine: mapping.generatedLine,\n          generatedColumn: mapping.generatedColumn,\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: mapping.name === null ? null : this._names.at(mapping.name)\n        };\n      }, this).forEach(aCallback, context);\n    }\n\n    /**\n     * Find the mapping that best matches the hypothetical \"needle\" mapping that\n     * we are searching for in the given \"haystack\" of mappings.\n     */\n  }, {\n    key: \"_findMapping\",\n    value: function _findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {\n      // To return the position we are searching for, we must first find the\n      // mapping for the given position and then return the opposite position it\n      // points to. Because the mappings are sorted, we can use binary search to\n      // find the best mapping.\n\n      if (aNeedle[aLineName] <= 0) {\n        throw new TypeError(\"Line must be greater than or equal to 1, got \" + aNeedle[aLineName]);\n      }\n      if (aNeedle[aColumnName] < 0) {\n        throw new TypeError(\"Column must be greater than or equal to 0, got \" + aNeedle[aColumnName]);\n      }\n      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n    }\n  }, {\n    key: \"allGeneratedPositionsFor\",\n    value: function allGeneratedPositionsFor(aArgs) {\n      var line = util.getArg(aArgs, \"line\");\n\n      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n      // returns the index of the closest mapping less than the needle. By\n      // setting needle.originalColumn to 0, we thus find the last mapping for\n      // the given line, provided such a mapping exists.\n      var needle = {\n        source: util.getArg(aArgs, \"source\"),\n        originalLine: line,\n        originalColumn: util.getArg(aArgs, \"column\", 0)\n      };\n      needle.source = this._findSourceIndex(needle.source);\n      if (needle.source < 0) {\n        return [];\n      }\n      if (needle.originalLine < 1) {\n        throw new Error(\"Line numbers must be >= 1\");\n      }\n      if (needle.originalColumn < 0) {\n        throw new Error(\"Column numbers must be >= 0\");\n      }\n      var mappings = [];\n      var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);\n      if (index >= 0) {\n        var mapping = this._originalMappings[index];\n        if (aArgs.column === undefined) {\n          var originalLine = mapping.originalLine;\n\n          // Iterate until either we run out of mappings, or we run into\n          // a mapping for a different line than the one we found. Since\n          // mappings are sorted, this is guaranteed to find all mappings for\n          // the line we found.\n          while (mapping && mapping.originalLine === originalLine) {\n            var lastColumn = mapping.lastGeneratedColumn;\n            if (this._computedColumnSpans && lastColumn === null) {\n              lastColumn = Infinity;\n            }\n            mappings.push({\n              line: util.getArg(mapping, \"generatedLine\", null),\n              column: util.getArg(mapping, \"generatedColumn\", null),\n              lastColumn: lastColumn\n            });\n            mapping = this._originalMappings[++index];\n          }\n        } else {\n          var originalColumn = mapping.originalColumn;\n\n          // Iterate until either we run out of mappings, or we run into\n          // a mapping for a different line than the one we were searching for.\n          // Since mappings are sorted, this is guaranteed to find all mappings for\n          // the line we are searching for.\n          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {\n            var _lastColumn = mapping.lastGeneratedColumn;\n            if (this._computedColumnSpans && _lastColumn === null) {\n              _lastColumn = Infinity;\n            }\n            mappings.push({\n              line: util.getArg(mapping, \"generatedLine\", null),\n              column: util.getArg(mapping, \"generatedColumn\", null),\n              lastColumn: _lastColumn\n            });\n            mapping = this._originalMappings[++index];\n          }\n        }\n      }\n      return mappings;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      for (var i = 0; i < this._sections.length; i++) {\n        this._sections[i].consumer.destroy();\n      }\n    }\n  }]);\n  return IndexedSourceMapConsumer;\n}(SourceMapConsumer);\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n  var consumer = sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}","map":{"version":3,"names":["util","require","binarySearch","ArraySet","base64VLQ","readWasm","wasm","INTERNAL","Symbol","SourceMapConsumer","aSourceMap","aSourceMapURL","Promise","resolve","_factory","aStr","aSourceRoot","Error","aCallback","aContext","aOrder","aArgs","opts","initialize","_factoryBSM","rawSourceMap","sourceMapUrl","f","consumer","destroy","prototype","_version","GENERATED_ORDER","ORIGINAL_ORDER","GREATEST_LOWER_BOUND","LEAST_UPPER_BOUND","exports","BasicSourceMapConsumer","then","that","sourceMap","parseSourceMapInput","version","getArg","sources","names","sourceRoot","sourcesContent","mappings","file","normalize","map","String","source","isAbsolute","relative","_names","fromArray","_sources","_absoluteSources","toArray","s","computeSourceURL","_mappings","_sourceMapURL","_computedColumnSpans","_mappingsPtr","_wasm","w","aSource","relativeSource","has","indexOf","i","length","slice","_parseMappings","size","mappingsBufPtr","allocate_mappings","mappingsBuf","Uint8Array","memory","buffer","charCodeAt","mappingsPtr","parse_mappings","error","get_last_error","msg","context","order","withMappingCallback","mapping","at","name","call","by_generated_location","_getMappingsPtr","by_original_location","originalLine","originalColumn","column","_findSourceIndex","m","lastColumn","lastGeneratedColumn","Infinity","push","line","generatedLine","generatedColumn","all_generated_locations_for","free_mappings","compute_column_spans","needle","bias","original_location_for","some","sc","nullOnMissing","index","url","urlParse","fileUriAbsPath","replace","scheme","path","generated_location_for","toString","IndexedSourceMapConsumer","sections","__generatedMappings","__originalMappings","__generatedMappingsUnsorted","__originalMappingsUnsorted","lastOffset","all","offset","offsetLine","offsetColumn","cons","generatedOffset","_sections","_sortGeneratedMappings","_sortOriginalMappings","_generatedMappingsUnsorted","sort","compareByGeneratedPositionsDeflated","_originalMappingsUnsorted","compareByOriginalPositions","j","sectionIndex","search","aNeedle","section","cmp","originalPositionFor","every","hasContentsOfAllSources","content","sourceContentFor","generatedPosition","generatedPositionFor","ret","generatedMappings","originalMappings","sectionMappings","eachMapping","add","adjustedMapping","_generatedMappings","_originalMappings","forEach","aMappings","aLineName","aColumnName","aComparator","aBias","TypeError","_findMapping","undefined","fromSourceMap"],"sources":["/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/stylus/node_modules/source-map/lib/source-map-consumer.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      let sources = util.getArg(sourceMap, \"sources\");\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      let sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      if (sourceRoot) {\n        sourceRoot = util.normalize(sourceRoot);\n      }\n\n      sources = sources\n        .map(String)\n        // Some source maps produce relative source paths like \"./foo.js\" instead of\n        // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n        // See bugzil.la/1090768.\n        .map(util.normalize)\n        // Always ensure that absolute sources are internally stored relative to\n        // the source root, if the source root is absolute. Not doing this would\n        // be particularly problematic when the source root is a prefix of the\n        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n        .map(function(source) {\n          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n            ? util.relative(sourceRoot, source)\n            : source;\n        });\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = that._sources.toArray().map(function(s) {\n        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n      });\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    if (this._sources.has(relativeSource)) {\n      return this._sources.indexOf(relativeSource);\n    }\n\n    // Maybe aSource is an absolute URL as returned by |sources|.  In\n    // this case we can't simply undo the transform.\n    for (let i = 0; i < this._absoluteSources.length; ++i) {\n      if (this._absoluteSources[i] == aSource) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.slice();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const size = aStr.length;\n\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size);\n    const mappingsBuf = new Uint8Array(this._wasm.exports.memory.buffer, mappingsBufPtr, size);\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `fitzgen/source-map-mappings`.\n      switch (error) {\n        case 1:\n          msg += \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    const sourceRoot = this.sourceRoot;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._sources.at(mapping.source);\n          mapping.source = util.computeSourceURL(sourceRoot, mapping.source, this._sourceMapURL);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n        case SourceMapConsumer.GENERATED_ORDER:\n          this._wasm.exports.by_generated_location(this._getMappingsPtr());\n          break;\n        case SourceMapConsumer.ORIGINAL_ORDER:\n          this._wasm.exports.by_original_location(this._getMappingsPtr());\n          break;\n        default:\n          throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      }, () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.original_location_for(\n        this._getMappingsPtr(),\n        needle.generatedLine - 1,\n        needle.generatedColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function(sc) { return sc == null; });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    let relativeSource = aSource;\n    if (this.sourceRoot != null) {\n      relativeSource = util.relative(this.sourceRoot, relativeSource);\n    }\n\n    let url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      const fileUriAbsPath = relativeSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + relativeSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + relativeSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + relativeSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\")\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(aArgs, \"bias\", SourceMapConsumer.GREATEST_LOWER_BOUND);\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(m => mapping = m, () => {\n      this._wasm.exports.generated_location_for(\n        this._getMappingsPtr(),\n        needle.source,\n        needle.originalLine - 1,\n        needle.originalColumn,\n        bias\n      );\n    });\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sources = new ArraySet();\n      that._names = new ArraySet();\n      that.__generatedMappings = null;\n      that.__originalMappings = null;\n      that.__generatedMappingsUnsorted = null;\n      that.__originalMappingsUnsorted = null;\n\n      let lastOffset = {\n        line: -1,\n        column: 0\n      };\n      return Promise.all(sections.map(s => {\n        if (s.url) {\n          // The url field will require support for asynchronicity.\n          // See https://github.com/mozilla/source-map/issues/16\n          throw new Error(\"Support for url field in sections not implemented.\");\n        }\n        const offset = util.getArg(s, \"offset\");\n        const offsetLine = util.getArg(offset, \"line\");\n        const offsetColumn = util.getArg(offset, \"column\");\n\n        if (offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n          throw new Error(\"Section offsets must be ordered and non-overlapping.\");\n        }\n        lastOffset = offset;\n\n        const cons = new SourceMapConsumer(util.getArg(s, \"map\"), aSourceMapURL);\n        return cons.then(consumer => {\n          return {\n            generatedOffset: {\n              // The offset fields are 0-based, but we use 1-based indices when\n              // encoding/decoding from VLQ.\n              generatedLine: offsetLine + 1,\n              generatedColumn: offsetColumn + 1\n            },\n            consumer\n          };\n        });\n      })).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n  get _generatedMappings() {\n    if (!this.__generatedMappings) {\n      this._sortGeneratedMappings();\n    }\n\n    return this.__generatedMappings;\n  }\n\n  get _originalMappings() {\n    if (!this.__originalMappings) {\n      this._sortOriginalMappings();\n    }\n\n    return this.__originalMappings;\n  }\n\n  get _generatedMappingsUnsorted() {\n    if (!this.__generatedMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappingsUnsorted;\n  }\n\n  get _originalMappingsUnsorted() {\n    if (!this.__originalMappingsUnsorted) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappingsUnsorted;\n  }\n\n  _sortGeneratedMappings() {\n    const mappings = this._generatedMappingsUnsorted;\n    mappings.sort(util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = mappings;\n  }\n\n  _sortOriginalMappings() {\n    const mappings = this._originalMappingsUnsorted;\n    mappings.sort(util.compareByOriginalPositions);\n    this.__originalMappings = mappings;\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\")\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(needle, this._sections,\n      function(aNeedle, section) {\n        const cmp = aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (aNeedle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function(s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer._findSourceIndex(util.getArg(aArgs, \"source\")) === -1) {\n        continue;\n      }\n      const generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        const ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings(aStr, aSourceRoot) {\n    const generatedMappings = this.__generatedMappingsUnsorted = [];\n    const originalMappings = this.__originalMappingsUnsorted = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const sectionMappings = [];\n      section.consumer.eachMapping(m => sectionMappings.push(m));\n\n      for (let j = 0; j < sectionMappings.length; j++) {\n        const mapping = sectionMappings[j];\n\n        // TODO: test if null is correct here.  The original code used\n        // `source`, which would actually have gotten used as null because\n        // var's get hoisted.\n        // See: https://github.com/mozilla/source-map/issues/333\n        let source = util.computeSourceURL(section.consumer.sourceRoot, null, this._sourceMapURL);\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        let name = null;\n        if (mapping.name) {\n          this._names.add(mapping.name);\n          name = this._names.indexOf(mapping.name);\n        }\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        const adjustedMapping = {\n          source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name\n        };\n\n        generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === \"number\") {\n          originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    let mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    const sourceRoot = this.sourceRoot;\n    mappings.map(function(mapping) {\n      let source = null;\n      if (mapping.source !== null) {\n        source = this._sources.at(mapping.source);\n        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);\n      }\n      return {\n        source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  }\n\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n  _findMapping(aNeedle, aMappings, aLineName,\n              aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError(\"Line must be greater than or equal to 1, got \"\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError(\"Column must be greater than or equal to 0, got \"\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const line = util.getArg(aArgs, \"line\");\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    const needle = {\n      source: util.getArg(aArgs, \"source\"),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, \"column\", 0)\n    };\n\n    needle.source = this._findSourceIndex(needle.source);\n    if (needle.source < 0) {\n      return [];\n    }\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    let index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      let mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        const originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        const originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          let lastColumn = mapping.lastGeneratedColumn;\n          if (this._computedColumnSpans && lastColumn === null) {\n            lastColumn = Infinity;\n          }\n          mappings.push({\n            line: util.getArg(mapping, \"generatedLine\", null),\n            column: util.getArg(mapping, \"generatedColumn\", null),\n            lastColumn,\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer = sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}