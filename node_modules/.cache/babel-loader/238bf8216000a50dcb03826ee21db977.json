{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n  throw new Error('\"' + aName + '\" is a required argument.');\n}\nexports.getArg = getArg;\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\nfunction urlGenerate(aParsedUrl) {\n  var url = \"\";\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + \":\";\n  }\n  url += \"//\";\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + \"@\";\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\nvar MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  var cache = [];\n  return function (input) {\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        var temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n    var result = f(input);\n    cache.unshift({\n      input: input,\n      result: result\n    });\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nvar normalize = lruMemoize(function normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  var parts = [];\n  var start = 0;\n  var i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n  var up = 0;\n  for (i = parts.length - 1; i >= 0; i--) {\n    var part = parts[i];\n    if (part === \".\") {\n      parts.splice(i, 1);\n    } else if (part === \"..\") {\n      up++;\n    } else if (up > 0) {\n      if (part === \"\") {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join(\"/\");\n  if (path === \"\") {\n    path = isAbsolute ? \"/\" : \".\";\n  }\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || \"/\";\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n  var joined = aPath.charAt(0) === \"/\" ? aPath : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  aRoot = aRoot.replace(/\\/$/, \"\");\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\nvar supportsNullProto = function () {\n  var obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}();\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n  var length = s.length;\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95 /* '_' */ || s.charCodeAt(length - 2) !== 95 /* '_' */ || s.charCodeAt(length - 3) !== 111 /* 'o' */ || s.charCodeAt(length - 4) !== 116 /* 't' */ || s.charCodeAt(length - 5) !== 111 /* 'o' */ || s.charCodeAt(length - 6) !== 114 /* 'r' */ || s.charCodeAt(length - 7) !== 112 /* 'p' */ || s.charCodeAt(length - 8) !== 95 /* '_' */ || s.charCodeAt(length - 9) !== 95 /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || \"\";\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n      sourceRoot += \"/\";\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf(\"/\");\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;","map":{"version":3,"names":["getArg","aArgs","aName","aDefaultValue","arguments","length","Error","exports","urlRegexp","dataUrlRegexp","urlParse","aUrl","match","scheme","auth","host","port","path","urlGenerate","aParsedUrl","url","MAX_CACHED_INPUTS","lruMemoize","f","cache","input","i","temp","result","unshift","pop","normalize","aPath","isAbsolute","parts","start","indexOf","push","slice","up","part","splice","join","aRoot","aPathUrl","aRootUrl","joined","charAt","replace","test","relative","level","index","lastIndexOf","Array","substr","supportsNullProto","obj","Object","create","identity","s","toSetString","aStr","isProtoString","fromSetString","charCodeAt","compareByOriginalPositions","mappingA","mappingB","onlyCompareOriginal","cmp","strcmp","source","originalLine","originalColumn","generatedColumn","generatedLine","name","compareByGeneratedPositionsDeflated","onlyCompareGenerated","aStr1","aStr2","compareByGeneratedPositionsInflated","parseSourceMapInput","str","JSON","parse","computeSourceURL","sourceRoot","sourceURL","sourceMapURL","parsed","substring"],"sources":["/Users/lisasavoie/Desktop/React-For-Beginners-Starter-Files-master/catch-of-the-day/node_modules/stylus/node_modules/source-map/lib/util.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n    throw new Error('\"' + aName + '\" is a required argument.');\n\n}\nexports.getArg = getArg;\n\nconst urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nconst dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  const match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  let url = \"\";\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + \":\";\n  }\n  url += \"//\";\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + \"@\";\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port;\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nconst MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  const cache = [];\n\n  return function(input) {\n    for (let i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        const temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    const result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nconst normalize = lruMemoize(function normalize(aPath) {\n  let path = aPath;\n  const url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  const isAbsolute = exports.isAbsolute(path);\n\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  const parts = [];\n  let start = 0;\n  let i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  let up = 0;\n  for (i = parts.length - 1; i >= 0; i--) {\n    const part = parts[i];\n    if (part === \".\") {\n      parts.splice(i, 1);\n    } else if (part === \"..\") {\n      up++;\n    } else if (up > 0) {\n      if (part === \"\") {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join(\"/\");\n\n  if (path === \"\") {\n    path = isAbsolute ? \"/\" : \".\";\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  const aPathUrl = urlParse(aPath);\n  const aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || \"/\";\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  const joined = aPath.charAt(0) === \"/\"\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, \"\") + \"/\" + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function(aPath) {\n  return aPath.charAt(0) === \"/\" || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, \"\");\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  let level = 0;\n  while (aPath.indexOf(aRoot + \"/\") !== 0) {\n    const index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nconst supportsNullProto = (function() {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n}());\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  let cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || \"\";\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== \"/\" && sourceURL[0] !== \"/\") {\n      sourceRoot += \"/\";\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   “sources” entry.  This value is prepended to the individual\n    //   entries in the “source” field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   “sourceRoot”, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    const parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      const index = parsed.path.lastIndexOf(\"/\");\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}